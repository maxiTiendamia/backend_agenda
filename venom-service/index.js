require('dotenv').config();
const express = require("express");
const { Pool } = require("pg");
const fs = require("fs");
const path = require("path");
const venom = require("venom-bot");
const axios = require("axios");
const app = express();
const PORT = process.env.PORT || 3000;
app.use(express.json());

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

const sessions = {};
const reconnectIntervals = {}; // Para manejar intervalos de reconexi√≥n

// Funci√≥n para verificar el estado de una sesi√≥n
async function verificarEstadoSesion(clienteId) {
  try {
    if (sessions[clienteId] && sessions[clienteId].client) {
      const isConnected = await sessions[clienteId].client.isConnected();
      return isConnected;
    }
    return false;
  } catch (error) {
    console.log(`‚ùå Error verificando sesi√≥n ${clienteId}:`, error.message);
    return false;
  }
}

// Funci√≥n para reconectar sesi√≥n autom√°ticamente
async function reconectarSesion(clienteId) {
  console.log(`üîÑ Intentando reconectar sesi√≥n ${clienteId}...`);
  
  // Limpiar sesi√≥n anterior si existe
  if (sessions[clienteId]) {
    try {
      if (sessions[clienteId].client && typeof sessions[clienteId].client.close === 'function') {
        await sessions[clienteId].client.close();
      }
    } catch (e) {
      console.log(`‚ö†Ô∏è Error cerrando sesi√≥n anterior ${clienteId}:`, e.message);
    }
    delete sessions[clienteId];
  }
  
  try {
    await crearSesionConTimeout(clienteId, 45000, false); // Sin guardar QR en reconexi√≥n
    console.log(`‚úÖ Sesi√≥n ${clienteId} reconectada exitosamente`);
  } catch (error) {
    console.log(`‚ùå Error reconectando sesi√≥n ${clienteId}:`, error.message);
    
    // Programar siguiente intento de reconexi√≥n
    setTimeout(() => {
      reconectarSesion(clienteId);
    }, 30000); // Reintentar en 30 segundos
  }
}

// Funci√≥n para monitorear todas las sesiones
async function monitorearSesiones() {
  for (const clienteId in sessions) {
    const estaConectada = await verificarEstadoSesion(clienteId);
    
    if (!estaConectada) {
      console.log(`üîç Sesi√≥n ${clienteId} desconectada, iniciando reconexi√≥n...`);
      
      // Evitar m√∫ltiples reconexiones simult√°neas
      if (!reconnectIntervals[clienteId]) {
        reconnectIntervals[clienteId] = true;
        await reconectarSesion(clienteId);
        delete reconnectIntervals[clienteId];
      }
    }
  }
}

// Iniciar monitoreo cada 2 minutos
setInterval(monitorearSesiones, 120000);

pool.connect()
  .then(async (client) => {
    console.log("‚úÖ Conexi√≥n a PostgreSQL exitosa");
    client.release();
    
    // Verificar qu√© clientes existen en la base de datos
    try {
      const result = await pool.query("SELECT id, comercio FROM tenants");
      console.log(`üìä Clientes encontrados en DB:`, result.rows.map(r => `${r.id}(${r.comercio})`));
    } catch (err) {
      console.error("‚ùå Error verificando clientes en DB:", err);
    }
  })
  .catch((err) => {
    console.error("‚ùå Error al conectar con la base de datos:", err);
  });

function crearSesionConTimeout(clienteId, timeoutMs = 60000, permitirGuardarQR = true) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      console.log(`‚è±Ô∏è Timeout alcanzado para sesi√≥n ${clienteId} (${timeoutMs}ms)`);
      reject(new Error("‚è± Tiempo de espera agotado para crear sesi√≥n"));
    }, timeoutMs);
    
    crearSesion(clienteId, permitirGuardarQR).then((res) => {
      clearTimeout(timer);
      resolve(res);
    }).catch((err) => {
      clearTimeout(timer);
      reject(err);
    });
  });
}

async function crearSesion(clienteId, permitirGuardarQR = true) {
  const sessionId = String(clienteId);
  const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
  const qrPath = path.join(sessionDir, `${sessionId}.html`);

  // Si se pide regenerar QR, borra el archivo, la sesi√≥n en memoria y el campo en la base
  if (permitirGuardarQR) {
    console.log(`üßπ Limpiando datos previos para cliente ${sessionId}...`);
    
    // Limpiar archivo QR HTML
    if (fs.existsSync(qrPath)) {
      fs.unlinkSync(qrPath);
      console.log(`üóëÔ∏è Archivo QR HTML eliminado: ${qrPath}`);
    }
    
    // Cerrar sesi√≥n en memoria si existe
    if (sessions[sessionId]) {
      try {
        await sessions[sessionId].close();
        console.log(`üîí Sesi√≥n en memoria cerrada para ${sessionId}`);
      } catch (e) {
        console.log(`‚ö†Ô∏è Error cerrando sesi√≥n anterior: ${e.message}`);
      }
      delete sessions[sessionId];
    }
    
    // Limpiar QR en base de datos
    try {
      const result = await pool.query("UPDATE tenants SET qr_code = NULL WHERE id = $1", [sessionId]);
      console.log(`üßπ QR limpiado en DB para cliente ${sessionId}, filas afectadas: ${result.rowCount}`);
      
      if (result.rowCount === 0) {
        console.log(`‚ö†Ô∏è Cliente ${sessionId} no encontrado en DB para limpiar QR`);
      }
    } catch (err) {
      console.error(`‚ùå Error limpiando QR en DB para ${sessionId}:`, err);
    }
  }

  if (sessions[sessionId]) {
    console.log(`üü° Sesi√≥n ya activa para ${sessionId}`);
    return sessions[sessionId];
  }

  console.log(`‚öôÔ∏è Iniciando sesi√≥n para ${sessionId}...`);
  if (!fs.existsSync(sessionDir)) {
    fs.mkdirSync(sessionDir);
    console.log("üìÅ Carpeta 'sessions' creada");
  }

  // Variable para controlar si ya se guard√≥ el QR (evitar m√∫ltiples guardados)
  let qrGuardado = false;

  try {
    const client = await venom.create({
      session: sessionId,
      multidevice: true,
      disableWelcome: true,
      sessionFolder: sessionDir,
      autoClose: 180000,
      useChrome: true,
      browserArgs: [
        "--no-sandbox", 
        "--disable-setuid-sandbox",
        "--disable-dev-shm-usage",
        "--disable-accelerated-2d-canvas",
        "--no-first-run",
        "--no-zygote",
        "--disable-gpu",
        "--disable-background-timer-throttling",
        "--disable-backgrounding-occluded-windows",
        "--disable-renderer-backgrounding"
      ],
      puppeteerOptions: { 
        headless: "new",
        args: [
          "--no-sandbox",
          "--disable-setuid-sandbox"
        ]
      },
      createPathFileToken: true,
      catchQR: async (base64Qr) => {
        console.log(`üîç QR generado para cliente ${sessionId}, permitirGuardarQR: ${permitirGuardarQR}, qrGuardado: ${qrGuardado}`);
        
        if (!permitirGuardarQR) {
          console.log(`‚ö†Ô∏è No se guarda QR para cliente ${sessionId} (permitirGuardarQR = false)`);
          return;
        }
        
        if (qrGuardado) {
          console.log(`‚ö†Ô∏è QR ya guardado para cliente ${sessionId}, saltando duplicado`);
          return;
        }
        
        qrGuardado = true; // Marcar como guardado para evitar duplicados
        
        console.log(`üíæ Iniciando guardado de QR para cliente ${sessionId}...`);
        
        // Guardar HTML del QR
        const html = `<html><body style="display:flex;justify-content:center;align-items:center;height:100vh;"><img src="${base64Qr}" /></body></html>`;
        const qrPath = path.join(sessionDir, `${sessionId}.html`);
        try {
          fs.writeFileSync(qrPath, html);
          console.log(`üìÑ QR HTML guardado en: ${qrPath}`);
        } catch (err) {
          console.error(`‚ùå Error guardando QR HTML para ${sessionId}:`, err);
        }

        // Guardar en base de datos con manejo mejorado del base64
        try {
          let base64Clean = base64Qr;
          
          // Limpiar prefijos comunes de base64
          const prefijos = [
            'data:image/png;base64,',
            'data:image/jpeg;base64,',
            'data:image/jpg;base64,',
            'data:image/webp;base64,',
            'data:image/gif;base64,'
          ];
          
          for (const prefijo of prefijos) {
            if (base64Clean.startsWith(prefijo)) {
              base64Clean = base64Clean.substring(prefijo.length);
              break;
            }
          }
          
          console.log(`üîç Base64 original length: ${base64Qr.length}, limpio length: ${base64Clean.length}`);
          
          const result = await pool.query(
            "UPDATE tenants SET qr_code = $1 WHERE id = $2",
            [base64Clean, sessionId]
          );
          
          console.log(`üì¨ QR guardado en DB para cliente ${sessionId}, filas afectadas: ${result.rowCount}`);
          
          if (result.rowCount === 0) {
            console.error(`‚ö†Ô∏è No se encontr√≥ cliente ${sessionId} en la base de datos para actualizar QR`);
          } else {
            console.log(`‚úÖ QR persistido exitosamente en DB para cliente ${sessionId}`);
          }
          
        } catch (err) {
          console.error(`‚ùå Error guardando QR en DB para cliente ${sessionId}:`, err);
          console.error(`üîç Detalles del error:`, {
            message: err.message,
            code: err.code,
            detail: err.detail
          });
        }
      },
    });

    sessions[sessionId] = client;

    // Manejar reconexi√≥n autom√°tica con limitador
    let reconexionIntentos = 0;
    const maxIntentos = 3;
    
    client.onStateChange(async (state) => {
      console.log(`üü† Estado de la sesi√≥n ${sessionId}:`, state);
      
      if (state === "CONNECTED") {
        reconexionIntentos = 0; // Reset contador cuando se conecta exitosamente
        console.log(`‚úÖ Sesi√≥n ${sessionId} conectada exitosamente`);
      }
      
      if (["CONFLICT", "UNPAIRED", "UNLAUNCHED", "DISCONNECTED"].includes(state)) {
        if (reconexionIntentos < maxIntentos) {
          reconexionIntentos++;
          console.log(`üîÑ Intento ${reconexionIntentos}/${maxIntentos} de reconexi√≥n para ${sessionId}...`);
          
          // Esperar antes de intentar reconectar
          await new Promise(resolve => setTimeout(resolve, 5000));
          
          try {
            // Cerrar sesi√≥n actual antes de recrear
            if (sessions[sessionId]) {
              await sessions[sessionId].close();
              delete sessions[sessionId];
            }
            
            await crearSesion(sessionId, false);
            console.log(`‚úÖ Sesi√≥n ${sessionId} reconectada en intento ${reconexionIntentos}`);
          } catch (err) {
            console.error(`‚ùå Error en intento ${reconexionIntentos} de reconexi√≥n ${sessionId}:`, err.message);
            
            if (reconexionIntentos >= maxIntentos) {
              console.error(`üö´ M√°ximo de intentos alcanzado para ${sessionId}, requiere intervenci√≥n manual`);
            }
          }
        } else {
          console.error(`üö´ Sesi√≥n ${sessionId} desconectada permanentemente, requiere escaneo de QR`);
        }
      }
    });

    client.onMessage(async (message) => {
      try {
        const telefono = message.from.replace("@c.us", "");
        const mensaje = message.body;
        const cliente_id = sessionId;

        // Env√≠a el mensaje al backend y espera la respuesta
        const backendResponse = await axios.post(
          "https://backend-agenda-2.onrender.com/api/webhook",
          {
            telefono,
            mensaje,
            cliente_id
          }
        );

        // El backend debe responder con { mensaje: "texto a enviar" }
        const respuesta = backendResponse.data && backendResponse.data.mensaje;
        if (respuesta) {
          await client.sendText(`${telefono}@c.us`, respuesta);
        }
      } catch (err) {
        console.error("‚ùå Error reenviando mensaje a backend o enviando respuesta:", err);
      }
    });

    return client;
  } catch (err) {
    console.error(`‚ùå Error creando sesi√≥n para ${sessionId}:`, err);
    throw err;
  }
}

async function verificarEstadoSesiones() {
  console.log("üîç Verificando estado de todas las sesiones...");
  
  for (const [sessionId, client] of Object.entries(sessions)) {
    try {
      const estado = await client.getConnectionState();
      console.log(`üìä Sesi√≥n ${sessionId}: ${estado}`);
      
      if (estado !== "CONNECTED") {
        console.log(`‚ö†Ô∏è Sesi√≥n ${sessionId} no conectada, intentando reconectar...`);
        try {
          await client.close();
          delete sessions[sessionId];
          await crearSesion(sessionId, false);
        } catch (err) {
          console.error(`‚ùå Error reconectando ${sessionId}:`, err.message);
        }
      }
    } catch (err) {
      console.error(`‚ùå Error verificando estado de ${sessionId}:`, err.message);
      delete sessions[sessionId];
    }
  }
}

// Verificar sesiones cada 10 minutos (deshabilitado temporalmente)
// setInterval(verificarEstadoSesiones, 10 * 60 * 1000);

async function restaurarSesiones() {
  try {
    console.log("üîÑ Iniciando restauraci√≥n de sesiones...");
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    
    // Verificar cu√°les clientes existen en la base de datos PRIMERO
    let result;
    try {
      result = await pool.query("SELECT id, comercio FROM tenants WHERE activo = true ORDER BY id");
      console.log(`üìä Consultando base de datos... Encontrados ${result.rows.length} clientes activos`);
      if (result.rows.length > 0) {
        console.log(`üë• Clientes activos en DB:`, result.rows.map(r => `${r.id}(${r.comercio || 'Sin comercio'})`));
      } else {
        console.log("‚ö†Ô∏è No se encontraron clientes activos en la base de datos");
        return;
      }
    } catch (err) {
      console.error("‚ùå Error consultando clientes de la base de datos:", err);
      // Si falla la consulta con 'activo', intentar sin esa columna
      try {
        result = await pool.query("SELECT id, comercio FROM tenants ORDER BY id");
        console.log(`üìä Consultando base de datos (sin filtro activo)... Encontrados ${result.rows.length} clientes`);
      } catch (err2) {
        console.error("‚ùå Error en consulta alternativa:", err2);
        return;
      }
    }
    
    const clientesActivos = result.rows.map(row => String(row.id));
    
    // Buscar carpetas de sesi√≥n existentes
    if (!fs.existsSync(sessionDir)) {
      console.log("üìÅ No existe carpeta de sesiones, cre√°ndola...");
      fs.mkdirSync(sessionDir, { recursive: true });
    }

    let sessionFolders = [];
    
    // Priorizar /app/tokens si existe (para producci√≥n)
    if (fs.existsSync("/app/tokens")) {
      console.log("üîç Buscando carpetas en /app/tokens...");
      try {
        const appTokenFolders = fs.readdirSync("/app/tokens").filter(item => {
          const itemPath = path.join("/app/tokens", item);
          return fs.statSync(itemPath).isDirectory() && !isNaN(item) && clientesActivos.includes(item);
        });
        console.log(`üìÇ Encontradas ${appTokenFolders.length} carpetas v√°lidas en /app/tokens:`, appTokenFolders);
        
        sessionFolders = appTokenFolders.map(folder => ({
          id: folder,
          path: path.join("/app/tokens", folder)
        }));
      } catch (err) {
        console.error("‚ùå Error leyendo /app/tokens:", err.message);
      }
    }
    
    // Si no hay carpetas en /app/tokens, buscar en sessionDir local
    if (sessionFolders.length === 0) {
      try {
        const localFolders = fs.readdirSync(sessionDir).filter(item => {
          const itemPath = path.join(sessionDir, item);
          return fs.statSync(itemPath).isDirectory() && !isNaN(item) && clientesActivos.includes(item);
        });
        console.log(`üìÇ Encontradas ${localFolders.length} carpetas v√°lidas en ${sessionDir}:`, localFolders);
        
        sessionFolders = localFolders.map(folder => ({
          id: folder,
          path: path.join(sessionDir, folder)
        }));
      } catch (err) {
        console.error("‚ùå Error leyendo carpeta local:", err.message);
      }
    }
    console.log(`üîç Clientes activos en BD (strings): [${clientesActivos.join(', ')}]`);
    
    // Verificar estado de sesiones activas en memoria
    const sesionesEnMemoria = Object.keys(sessions);
    console.log(`üíæ Sesiones activas en memoria: [${sesionesEnMemoria.join(', ')}]`);
    
    // An√°lisis detallado de carpetas vs clientes
    const carpetasIds = sessionFolders.map(f => f.id);
    const clientesConCarpeta = clientesActivos.filter(id => carpetasIds.includes(id));
    const clientesSinCarpeta = clientesActivos.filter(id => !carpetasIds.includes(id));
    const carpetasHuerfanas = carpetasIds.filter(id => !clientesActivos.includes(id));
    
    console.log(`üìã AN√ÅLISIS COMPLETO:`);
    console.log(`  - Clientes con carpeta: [${clientesConCarpeta.join(', ')}]`);
    console.log(`  - Clientes sin carpeta: [${clientesSinCarpeta.join(', ')}]`);
    console.log(`  - Carpetas hu√©rfanas: [${carpetasHuerfanas.join(', ')}]`);
    
    // Verificar espec√≠ficamente el cliente 35
    if (clientesActivos.includes('35')) {
      console.log(`üîç DIAGN√ìSTICO CLIENTE 35:`);
      console.log(`  - Existe en BD: ‚úÖ`);
      console.log(`  - Tiene carpeta en disco: ${carpetasIds.includes('35') ? '‚úÖ' : '‚ùå'}`);
      console.log(`  - Sesi√≥n en memoria: ${sesionesEnMemoria.includes('35') ? '‚úÖ' : '‚ùå'}`);
      
      if (sessions['35']) {
        try {
          const estado35 = await sessions['35'].getConnectionState();
          console.log(`  - Estado actual: ${estado35}`);
        } catch (e) {
          console.log(`  - Error verificando estado: ${e.message}`);
        }
      }
      
      // Buscar carpeta 35 manualmente en ambas ubicaciones
      const paths35 = [
        path.join(sessionDir, '35'),
        '/app/tokens/35'
      ];
      
      for (const pathToCheck of paths35) {
        console.log(`  - Verificando ruta ${pathToCheck}: ${fs.existsSync(pathToCheck) ? '‚úÖ' : '‚ùå'}`);
        if (fs.existsSync(pathToCheck)) {
          const defaultPath = path.join(pathToCheck, 'Default');
          console.log(`    - Default folder: ${fs.existsSync(defaultPath) ? '‚úÖ' : '‚ùå'}`);
          if (fs.existsSync(pathToCheck)) {
            const files = fs.readdirSync(pathToCheck);
            console.log(`    - Archivos en carpeta: [${files.join(', ')}]`);
          }
        }
      }
    }
    
    for (const sessionFolder of sessionFolders) {
      const clienteId = typeof sessionFolder === 'string' ? sessionFolder : sessionFolder.id;
      const sessionPath = typeof sessionFolder === 'string' ? 
        path.join(sessionDir, sessionFolder) : sessionFolder.path;
      
      // Solo restaurar si el cliente existe en la base de datos
      if (!clientesActivos.includes(clienteId)) {
        console.log(`‚ö†Ô∏è Cliente ${clienteId} no existe en DB (Clientes v√°lidos: ${clientesActivos.join(', ')}), saltando...`);
        continue;
      }

      // Verificar si existe el archivo de datos de WhatsApp Web
      const defaultPath = path.join(sessionPath, "Default");
      const whatsappDataFile = path.join(sessionPath, "Default", "Local Storage");
      
      console.log(`üîç Verificando archivos para cliente ${clienteId}:`);
      console.log(`  - Ruta sesi√≥n: ${sessionPath}`);
      console.log(`  - Carpeta Default: ${fs.existsSync(defaultPath) ? '‚úÖ' : '‚ùå'}`);
      console.log(`  - Local Storage: ${fs.existsSync(whatsappDataFile) ? '‚úÖ' : '‚ùå'}`);
      
      if (fs.existsSync(defaultPath) || fs.existsSync(whatsappDataFile)) {
        console.log(`üîÑ Restaurando sesi√≥n para cliente ${clienteId}...`);
        console.log(`üìÅ Usando ruta: ${sessionPath}`);
        try {
          // Configurar la variable de entorno para esta sesi√≥n espec√≠fica
          const originalSessionFolder = process.env.SESSION_FOLDER;
          process.env.SESSION_FOLDER = path.dirname(sessionPath);
          
          await crearSesion(clienteId, false); // false = no regenerar QR
          console.log(`‚úÖ Sesi√≥n restaurada para cliente ${clienteId}`);
          
          // Restaurar configuraci√≥n original
          if (originalSessionFolder) {
            process.env.SESSION_FOLDER = originalSessionFolder;
          } else {
            delete process.env.SESSION_FOLDER;
          }
          
          // Esperar un poco entre restauraciones para no sobrecargar
          await new Promise(resolve => setTimeout(resolve, 3000));
        } catch (err) {
          console.error(`‚ùå Error restaurando sesi√≥n ${clienteId}:`, err.message);
          console.error(`üîç Stack trace:`, err.stack);
        }
      } else {
        console.log(`‚ö†Ô∏è No hay datos de sesi√≥n v√°lidos para cliente ${clienteId} en ${sessionPath}`);
        console.log(`üîç Archivos en la carpeta:`, fs.existsSync(sessionPath) ? fs.readdirSync(sessionPath) : "Carpeta no existe");
      }
    }
    
    console.log("‚úÖ Proceso de restauraci√≥n completado");
    
    // Verificar clientes activos que NO tienen carpetas de sesi√≥n
    console.log("üîç Verificando clientes activos sin carpetas de sesi√≥n...");
    const carpetasExistentes = sessionFolders.map(sf => typeof sf === 'string' ? sf : sf.id);
    const clientesSinCarpetas = clientesActivos.filter(id => !carpetasExistentes.includes(id));
    
    if (clientesSinCarpetas.length > 0) {
      console.log(`üìã Clientes sin carpetas de sesi√≥n:`, clientesSinCarpetas);
      console.log(`üöÄ Creando sesiones autom√°ticamente...`);
      
      for (const clienteId of clientesSinCarpetas) {
        try {
          console.log(`‚öôÔ∏è Creando sesi√≥n autom√°tica para cliente ${clienteId}...`);
          
          // Crear sesi√≥n con timeout m√°s corto y manejo de errores mejorado
          await Promise.race([
            crearSesion(clienteId, true), // true = generar QR
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error("Timeout de 30 segundos alcanzado")), 30000)
            )
          ]);
          
          console.log(`‚úÖ Sesi√≥n creada para cliente ${clienteId}. QR disponible en /qr/${clienteId}`);
          
        } catch (err) {
          console.error(`‚ùå Error creando sesi√≥n autom√°tica para ${clienteId}:`, err.message);
          console.log(`‚è≠Ô∏è Continuando con el siguiente cliente...`);
        }
        
        // Esperar un poco entre creaciones para no sobrecargar
        console.log(`‚è±Ô∏è Esperando 3 segundos antes del siguiente cliente...`);
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
      
      console.log(`üì± QR codes disponibles en:`);
      clientesSinCarpetas.forEach(id => {
        console.log(`  - https://backend-agenda-us92.onrender.com/qr/${id}`);
      });
    } else {
      console.log("‚úÖ Todos los clientes activos tienen carpetas de sesi√≥n");
    }
  } catch (err) {
    console.error("‚ùå Error restaurando sesiones previas:", err);
  }
}

app.get("/iniciar/:clienteId", async (req, res) => {
  const { clienteId } = req.params;
  try {
    await crearSesionConTimeout(clienteId, 60000, true); // <-- true para guardar QR
    res.send(`‚úÖ Sesi√≥n iniciada para ${clienteId}. Escane√° el QR en /qr/${clienteId}`);
  } catch (error) {
    console.error("‚ùå Error al iniciar sesi√≥n:", error);
    res.status(500).send("Error al iniciar sesi√≥n");
  }
});

app.get("/qr/:clienteId", (req, res) => {
  const clienteId = req.params.clienteId;
  const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
  const filePath = path.join(sessionDir, `${clienteId}.html`);
  if (fs.existsSync(filePath)) {
    res.sendFile(filePath);
  } else {
    res.status(404).send(`<h2>‚ö†Ô∏è A√∫n no se gener√≥ un QR para el cliente: ${clienteId}</h2>`);
  }
});

app.get("/estado", async (req, res) => {
  try {
    // Obtener clientes de la DB
    const result = await pool.query("SELECT id, comercio FROM tenants");
    const clientesDB = result.rows.map(r => ({ id: String(r.id), comercio: r.comercio }));
    
    // Obtener carpetas existentes
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    const carpetas = fs.existsSync(sessionDir) ? 
      fs.readdirSync(sessionDir).filter(item => {
        const itemPath = path.join(sessionDir, item);
        return fs.statSync(itemPath).isDirectory() && !isNaN(item);
      }) : [];
    
    // Estado de sesiones activas
    const sesionesActivas = Object.keys(sessions);
    
    // An√°lisis
    const clientesConCarpeta = clientesDB.filter(c => carpetas.includes(c.id));
    const clientesSinCarpeta = clientesDB.filter(c => !carpetas.includes(c.id));
    const carpetasHuerfanas = carpetas.filter(c => !clientesDB.find(cl => cl.id === c));
    
    res.json({
      timestamp: new Date().toISOString(),
      clientes_en_db: clientesDB.length,
      carpetas_en_disco: carpetas.length,
      sesiones_activas: sesionesActivas.length,
      clientes_db: clientesDB,
      carpetas_existentes: carpetas,
      sesiones_activas_ids: sesionesActivas,
      analisis: {
        clientes_con_carpeta: clientesConCarpeta,
        clientes_sin_carpeta: clientesSinCarpeta,
        carpetas_huerfanas: carpetasHuerfanas
      }
    });
  } catch (err) {
    console.error("‚ùå Error obteniendo estado:", err);
    res.status(500).json({ error: "Error obteniendo estado" });
  }
});

app.post("/enviar-mensaje", async (req, res) => {
  const { cliente_id, telefono, mensaje } = req.body;
  const session = sessions[String(cliente_id)];
  if (!session) return res.status(404).json({ error: "Sesi√≥n no encontrada para este cliente" });

  try {
    const state = await session.getConnectionState();
    if (state !== "CONNECTED") return res.status(400).json({ error: `Sesi√≥n no conectada (estado: ${state})` });
    await session.sendText(`${telefono}@c.us`, mensaje);
    res.json({ status: "mensaje enviado" });
  } catch (err) {
    console.error("‚ùå Error enviando mensaje:", err);
    res.status(500).json({ error: "Error al enviar mensaje" });
  }
});

app.get("/estado-sesiones", async (req, res) => {
  const estados = [];
  try {
    const result = await pool.query("SELECT id, nombre, comercio FROM tenants");
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    
    for (const cliente of result.rows) {
      const clienteId = String(cliente.id);
      let estado = "NO_INICIADA";
      let tieneArchivos = false;
      
      // Verificar si tiene archivos de sesi√≥n en disco
      const sessionPath = path.join(sessionDir, clienteId);
      if (fs.existsSync(sessionPath)) {
        const defaultPath = path.join(sessionPath, "Default");
        tieneArchivos = fs.existsSync(defaultPath);
      }
      
      // Tambi√©n verificar en /app/tokens si no se encuentra en la ruta local
      if (!tieneArchivos && fs.existsSync(`/app/tokens/${clienteId}`)) {
        const defaultPath = path.join(`/app/tokens/${clienteId}`, "Default");
        tieneArchivos = fs.existsSync(defaultPath);
      }
      
      if (sessions[clienteId]) {
        try {
          estado = await sessions[clienteId].getConnectionState();
        } catch (err) {
          estado = "ERROR";
          console.error(`‚ùå Error obteniendo estado de ${clienteId}:`, err.message);
        }
      } else if (tieneArchivos) {
        estado = "ARCHIVOS_DISPONIBLES";
      }
      
      estados.push({ 
        clienteId, 
        nombre: cliente.nombre, 
        comercio: cliente.comercio, 
        estado,
        tieneArchivos,
        enMemoria: !!sessions[clienteId]
      });
    }
    res.json(estados);
  } catch (error) {
    console.error("‚ùå Error consultando clientes:", error);
    res.status(500).json({ error: "Error consultando clientes" });
  }
});

app.get("/restaurar/:clienteId", async (req, res) => {
  const { clienteId } = req.params;
  try {
    console.log(`üîÑ Forzando restauraci√≥n de sesi√≥n para cliente ${clienteId}...`);
    
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    let sessionPath = path.join(sessionDir, clienteId);
    
    // Si no existe en la ruta local, buscar en /app/tokens
    if (!fs.existsSync(sessionPath) && fs.existsSync(`/app/tokens/${clienteId}`)) {
      sessionPath = `/app/tokens/${clienteId}`;
      console.log(`üìÅ Usando ruta alternativa: ${sessionPath}`);
    }
    
    if (!fs.existsSync(sessionPath)) {
      return res.status(404).json({ 
        error: "No se encontraron archivos de sesi√≥n para este cliente",
        requiereQR: true 
      });
    }
    
    // Cerrar sesi√≥n actual si existe
    if (sessions[clienteId]) {
      try {
        await sessions[clienteId].close();
      } catch (e) {
        console.log("No se pudo cerrar la sesi√≥n anterior:", e.message);
      }
      delete sessions[clienteId];
    }
    
    // Configurar la ruta de sesi√≥n temporalmente
    const originalSessionFolder = process.env.SESSION_FOLDER;
    process.env.SESSION_FOLDER = path.dirname(sessionPath);
    
    try {
      // Restaurar desde archivos del disco
      await crearSesion(clienteId, false);
      
      // Verificar estado despu√©s de restaurar
      let estado = "UNKNOWN";
      if (sessions[clienteId]) {
        try {
          // Esperar un poco para que la sesi√≥n se establezca
          await new Promise(resolve => setTimeout(resolve, 3000));
          estado = await sessions[clienteId].getConnectionState();
        } catch (err) {
          estado = "ERROR";
        }
      }
      
      res.json({ 
        success: true, 
        mensaje: `Sesi√≥n restaurada para cliente ${clienteId}`,
        estado: estado,
        rutaUsada: sessionPath
      });
    } finally {
      // Restaurar la configuraci√≥n original
      if (originalSessionFolder) {
        process.env.SESSION_FOLDER = originalSessionFolder;
      } else {
        delete process.env.SESSION_FOLDER;
      }
    }
  } catch (error) {
    console.error("‚ùå Error restaurando sesi√≥n:", error);
    res.status(500).json({ 
      error: "Error al restaurar sesi√≥n",
      details: error.message 
    });
  }
});

app.get("/debug/cliente/:clienteId", async (req, res) => {
  const { clienteId } = req.params;
  
  try {
    console.log(`üîç Diagn√≥stico detallado para cliente ${clienteId}...`);
    
    const diagnostico = {
      clienteId,
      timestamp: new Date().toISOString(),
      baseDatos: {},
      carpetas: {},
      sesionMemoria: {},
      venom: {}
    };
    
    // 1. Verificar en base de datos
    try {
      const result = await pool.query("SELECT id, nombre, comercio FROM tenants WHERE id = $1", [clienteId]);
      diagnostico.baseDatos = {
        existe: result.rows.length > 0,
        datos: result.rows[0] || null
      };
    } catch (err) {
      diagnostico.baseDatos = { error: err.message };
    }
    
    // 2. Verificar carpetas en disco
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    const rutasVerificar = [
      path.join(sessionDir, clienteId),
      `/app/tokens/${clienteId}`
    ];
    
    diagnostico.carpetas.rutas = {};
    for (const ruta of rutasVerificar) {
      const existe = fs.existsSync(ruta);
      diagnostico.carpetas.rutas[ruta] = {
        existe,
        archivos: existe ? fs.readdirSync(ruta) : [],
        defaultFolder: existe ? fs.existsSync(path.join(ruta, 'Default')) : false
      };
      
      if (existe) {
        const defaultPath = path.join(ruta, 'Default');
        if (fs.existsSync(defaultPath)) {
          diagnostico.carpetas.rutas[ruta].defaultFiles = fs.readdirSync(defaultPath);
          
          // Verificar archivos importantes de WhatsApp
          const archivosImportantes = [
            'Local Storage',
            'Session Storage', 
            'IndexedDB',
            'Preferences'
          ];
          
          diagnostico.carpetas.rutas[ruta].archivosImportantes = {};
          for (const archivo of archivosImportantes) {
            const archivoPath = path.join(defaultPath, archivo);
            diagnostico.carpetas.rutas[ruta].archivosImportantes[archivo] = fs.existsSync(archivoPath);
          }
        }
      }
    }
    
    // 3. Verificar sesi√≥n en memoria
    diagnostico.sesionMemoria = {
      existe: !!sessions[clienteId],
      tipo: sessions[clienteId] ? typeof sessions[clienteId] : null
    };
    
    if (sessions[clienteId]) {
      try {
        const estado = await sessions[clienteId].getConnectionState();
        diagnostico.sesionMemoria.estado = estado;
        
        const isConnected = await sessions[clienteId].isConnected();
        diagnostico.sesionMemoria.conectado = isConnected;
        
        // Intentar obtener informaci√≥n de la sesi√≥n
        try {
          const hostDevice = await sessions[clienteId].getHostDevice();
          diagnostico.sesionMemoria.dispositivo = hostDevice;
        } catch (e) {
          diagnostico.sesionMemoria.dispositivo = `Error: ${e.message}`;
        }
        
      } catch (err) {
        diagnostico.sesionMemoria.error = err.message;
      }
    }
    
    // 4. Verificar si Venom puede detectar la sesi√≥n
    try {
      // Simular las opciones que usar√≠a venom
      const carpetaEncontrada = rutasVerificar.find(ruta => fs.existsSync(ruta));
      
      if (carpetaEncontrada) {
        diagnostico.venom = {
          carpetaDetectada: carpetaEncontrada,
          puedeRestaurar: fs.existsSync(path.join(carpetaEncontrada, 'Default')),
          configuracion: {
            session: clienteId,
            userDataDir: carpetaEncontrada,
            browserArgs: [
              '--no-sandbox',
              '--disable-setuid-sandbox', 
              '--disable-dev-shm-usage'
            ]
          }
        };
      } else {
        diagnostico.venom = {
          carpetaDetectada: null,
          puedeRestaurar: false,
          requiereQR: true
        };
      }
    } catch (err) {
      diagnostico.venom = { error: err.message };
    }
    
    console.log(`üìã Diagn√≥stico completo para cliente ${clienteId}:`, JSON.stringify(diagnostico, null, 2));
    
    res.json(diagnostico);
    
  } catch (error) {
    console.error(`‚ùå Error en diagn√≥stico de cliente ${clienteId}:`, error);
    res.status(500).json({ error: error.message });
  }
});

app.get("/debug/clientes", async (req, res) => {
  try {
    const result = await pool.query("SELECT id, nombre, comercio FROM tenants ORDER BY id");
    res.json({
      total: result.rows.length,
      clientes: result.rows
    });
  } catch (error) {
    console.error("‚ùå Error consultando clientes:", error);
    res.status(500).json({ error: "Error consultando clientes", details: error.message });
  }
});

app.get("/debug/carpetas", (req, res) => {
  const carpetas = [];
  
  if (fs.existsSync("/app/tokens")) {
    const folders = fs.readdirSync("/app/tokens").filter(item => {
      const itemPath = path.join("/app/tokens", item);
      return fs.statSync(itemPath).isDirectory() && !isNaN(item);
    });
    
    folders.forEach(folder => {
      const folderPath = path.join("/app/tokens", folder);
      const defaultPath = path.join(folderPath, "Default");
      carpetas.push({
        id: folder,
        ruta: folderPath,
        tieneDefault: fs.existsSync(defaultPath),
        archivos: fs.existsSync(folderPath) ? fs.readdirSync(folderPath) : []
      });
    });
  }
  
  res.json({
    rutaTokens: "/app/tokens",
    existeRuta: fs.existsSync("/app/tokens"),
    carpetas: carpetas
  });
});

app.post("/admin/limpiar-carpetas-huerfanas", async (req, res) => {
  try {
    // Obtener clientes activos de la DB
    const result = await pool.query("SELECT id FROM tenants");
    const clientesActivos = result.rows.map(row => String(row.id));
    
    if (!fs.existsSync("/app/tokens")) {
      return res.json({ mensaje: "No existe la carpeta /app/tokens", carpetasEliminadas: [] });
    }
    
    // Encontrar carpetas hu√©rfanas
    const folders = fs.readdirSync("/app/tokens").filter(item => {
      const itemPath = path.join("/app/tokens", item);
      return fs.statSync(itemPath).isDirectory() && !isNaN(item);
    });
    
    const carpetasHuerfanas = folders.filter(folder => !clientesActivos.includes(folder));
    const carpetasEliminadas = [];
    
    for (const carpeta of carpetasHuerfanas) {
      const carpetaPath = path.join("/app/tokens", carpeta);
      try {
        // Eliminar recursivamente la carpeta
        fs.rmSync(carpetaPath, { recursive: true, force: true });
        carpetasEliminadas.push(carpeta);
        console.log(`üóëÔ∏è Carpeta eliminada: ${carpetaPath}`);
      } catch (err) {
        console.error(`‚ùå Error eliminando carpeta ${carpeta}:`, err.message);
      }
    }
    
    res.json({
      mensaje: `Limpieza completada. ${carpetasEliminadas.length} carpetas eliminadas.`,
      clientesActivos: clientesActivos,
      carpetasEncontradas: folders,
      carpetasHuerfanas: carpetasHuerfanas,
      carpetasEliminadas: carpetasEliminadas
    });
  } catch (error) {
    console.error("‚ùå Error limpiando carpetas hu√©rfanas:", error);
    res.status(500).json({ error: "Error limpiando carpetas", details: error.message });
  }
});

app.delete("/limpiar-huerfanas", async (req, res) => {
  try {
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    if (!fs.existsSync(sessionDir)) {
      return res.json({ mensaje: "No existe carpeta de sesiones", eliminadas: [] });
    }
    
    // Obtener clientes v√°lidos de la DB
    const result = await pool.query("SELECT id FROM tenants");
    const clientesValidos = result.rows.map(r => String(r.id));
    
    // Encontrar carpetas hu√©rfanas
    const carpetas = fs.readdirSync(sessionDir).filter(item => {
      const itemPath = path.join(sessionDir, item);
      return fs.statSync(itemPath).isDirectory() && !isNaN(item);
    });
    
    const carpetasHuerfanas = carpetas.filter(c => !clientesValidos.includes(c));
    const eliminadas = [];
    
    for (const carpeta of carpetasHuerfanas) {
      try {
        const carpetaPath = path.join(sessionDir, carpeta);
        console.log(`üóëÔ∏è Eliminando carpeta hu√©rfana: ${carpetaPath}`);
        
        // Cerrar sesi√≥n si est√° activa
        if (sessions[carpeta]) {
          await sessions[carpeta].close();
          delete sessions[carpeta];
        }
        
        // Eliminar carpeta recursivamente
        fs.rmSync(carpetaPath, { recursive: true, force: true });
        eliminadas.push(carpeta);
        console.log(`‚úÖ Carpeta ${carpeta} eliminada`);
      } catch (err) {
        console.error(`‚ùå Error eliminando carpeta ${carpeta}:`, err);
      }
    }
    
    res.json({
      mensaje: `Limpieza completada. ${eliminadas.length} carpetas eliminadas.`,
      carpetas_eliminadas: eliminadas,
      clientes_validos: clientesValidos
    });
  } catch (err) {
    console.error("‚ùå Error limpiando carpetas hu√©rfanas:", err);
    res.status(500).json({ error: "Error limpiando carpetas" });
  }
});

app.post("/forzar-nueva-sesion/:clienteId", async (req, res) => {
  const { clienteId } = req.params;
  
  try {
    console.log(`üîÑ Forzando nueva sesi√≥n para cliente ${clienteId}...`);
    
    // 1. Verificar que el cliente existe en la base de datos
    try {
      const result = await pool.query("SELECT id, comercio FROM tenants WHERE id = $1", [clienteId]);
      if (result.rows.length === 0) {
        return res.status(404).json({ 
          error: `Cliente ${clienteId} no existe en la base de datos`,
          accion: "verificar_cliente"
        });
      }
      console.log(`‚úÖ Cliente ${clienteId} encontrado en BD: ${result.rows[0].comercio}`);
    } catch (dbError) {
      console.error(`‚ùå Error verificando cliente en BD: ${dbError.message}`);
      // Continuar anyway si hay problemas de BD
    }
    
    // 2. Cerrar sesi√≥n existente si est√° en memoria
    if (sessions[clienteId]) {
      console.log(`üîí Cerrando sesi√≥n existente en memoria para ${clienteId}...`);
      try {
        await sessions[clienteId].close();
        console.log(`‚úÖ Sesi√≥n en memoria cerrada para ${clienteId}`);
      } catch (closeError) {
        console.log(`‚ö†Ô∏è Error cerrando sesi√≥n: ${closeError.message}`);
      }
      delete sessions[clienteId];
    }
    
    // 3. Limpiar archivos de sesi√≥n existentes si los hay
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    const rutasLimpiar = [
      path.join(sessionDir, clienteId),
      `/app/tokens/${clienteId}`
    ];
    
    for (const rutaLimpiar of rutasLimpiar) {
      if (fs.existsSync(rutaLimpiar)) {
        console.log(`üóëÔ∏è Eliminando carpeta de sesi√≥n: ${rutaLimpiar}`);
        try {
          fs.rmSync(rutaLimpiar, { recursive: true, force: true });
          console.log(`‚úÖ Carpeta eliminada: ${rutaLimpiar}`);
        } catch (deleteError) {
          console.log(`‚ö†Ô∏è Error eliminando carpeta: ${deleteError.message}`);
        }
      }
    }
    
    // 4. Limpiar QR en base de datos
    try {
      await pool.query("UPDATE tenants SET qr_code = NULL WHERE id = $1", [clienteId]);
      console.log(`‚úÖ QR limpiado en base de datos para cliente ${clienteId}`);
    } catch (dbError) {
      console.log(`‚ö†Ô∏è Error limpiando QR en BD: ${dbError.message}`);
    }
    
    // 5. Crear nueva sesi√≥n desde cero
    console.log(`üöÄ Creando nueva sesi√≥n desde cero para cliente ${clienteId}...`);
    
    try {
      await crearSesionConTimeout(clienteId, 30000, true); // 30 segundos timeout, generar QR
      
      const response = {
        success: true,
        mensaje: `Nueva sesi√≥n creada para cliente ${clienteId}`,
        accion: "escanear_qr",
        qr_url: `/qr/${clienteId}`,
        timestamp: new Date().toISOString()
      };
      
      console.log(`‚úÖ Nueva sesi√≥n creada exitosamente para cliente ${clienteId}`);
      res.json(response);
      
    } catch (createError) {
      console.error(`‚ùå Error creando nueva sesi√≥n: ${createError.message}`);
      res.status(500).json({
        error: "Error creando nueva sesi√≥n",
        details: createError.message,
        accion: "reintentar",
        qr_url: `/qr/${clienteId}` // Intentar mostrar QR anyway
      });
    }
    
  } catch (error) {
    console.error(`‚ùå Error en forzar-nueva-sesion para ${clienteId}:`, error);
    res.status(500).json({ 
      error: "Error interno del servidor",
      details: error.message 
    });
  }
});

app.post("/notificar-chat-humano", async (req, res) => {
  try {
    const { cliente_id, telefono, mensaje, tipo } = req.body;
    
    if (!cliente_id || !telefono) {
      return res.status(400).json({ error: "cliente_id y telefono son requeridos" });
    }
    
    console.log(`üö® ==========================================`);
    console.log(`üö® ALERTA: ATENCI√ìN HUMANA REQUERIDA`);
    console.log(`üö® ==========================================`);
    console.log(`üìû Cliente ID: ${cliente_id}`);
    console.log(`üì± Tel√©fono: ${telefono}`);
    console.log(`üí¨ √öltimo mensaje: ${mensaje}`);
    console.log(`üîî Tipo: ${tipo || 'solicitud_ayuda'}`);
    console.log(`‚è∞ Fecha: ${new Date().toLocaleString('es-AR')}`);
    
    // Buscar informaci√≥n del cliente en la base de datos
    let comercio = 'N/A';
    let nombre = 'N/A';
    try {
      const clienteInfo = await pool.query("SELECT comercio, nombre FROM tenants WHERE id = $1", [cliente_id]);
      if (clienteInfo.rows.length > 0) {
        comercio = clienteInfo.rows[0].comercio || 'N/A';
        nombre = clienteInfo.rows[0].nombre || 'N/A';
        console.log(`üè¢ Comercio: ${comercio}`);
        console.log(`üë§ Contacto: ${nombre}`);
      }
    } catch (err) {
      console.log(`‚ö†Ô∏è No se pudo obtener info del cliente: ${err.message}`);
    }
    
    console.log(`üö® ==========================================`);
    console.log(`üí° El usuario puede escribir "Bot" para volver al asistente virtual`);
    console.log(`üö® ==========================================`);
    
    // Enviar mensaje de notificaci√≥n al propio n√∫mero del bot/propietario
    let mensajeEnviado = false;
    let errorEnvio = null;
    
    const session = sessions[String(cliente_id)];
    if (session) {
      try {
        // Verificar que la sesi√≥n est√© conectada
        const state = await session.getConnectionState();
        if (state === "CONNECTED") {
          // Crear mensaje de notificaci√≥n
          const mensajeNotificacion = `üö® *SOLICITUD DE AYUDA HUMANA* üö®

üë§ *Cliente:* ${nombre}
üè¢ *Comercio:* ${comercio}
üì± *Tel√©fono:* ${telefono}
üí¨ *√öltimo mensaje:* ${mensaje}
‚è∞ *Fecha:* ${new Date().toLocaleString('es-AR')}

‚ÑπÔ∏è El cliente solicita atenci√≥n humana. Responde normalmente a este chat.
üí° El cliente puede escribir "Bot" para volver al asistente virtual.`;

          // Obtener el n√∫mero propio del bot para enviar la autonotificaci√≥n
          const hostDevice = await session.getHostDevice();
          const numeroPropio = hostDevice.id.user; // N√∫mero del propietario del WhatsApp
          
          await session.sendText(`${numeroPropio}@c.us`, mensajeNotificacion);
          mensajeEnviado = true;
          
          console.log(`üì® Autonotificaci√≥n enviada al n√∫mero propio: ${numeroPropio}`);
        } else {
          errorEnvio = `Sesi√≥n no conectada (estado: ${state})`;
          console.log(`‚ö†Ô∏è No se pudo enviar autonotificaci√≥n: ${errorEnvio}`);
        }
      } catch (err) {
        errorEnvio = err.message;
        console.error("‚ùå Error enviando autonotificaci√≥n:", err);
      }
    } else {
      errorEnvio = "Sesi√≥n no encontrada";
      console.log(`‚ö†Ô∏è No se pudo enviar autonotificaci√≥n: ${errorEnvio}`);
    }
    
    res.json({ 
      success: true, 
      mensaje: "Notificaci√≥n de chat humano registrada",
      cliente_id,
      telefono,
      action: "logged_and_notified",
      autonotificacion: {
        enviada: mensajeEnviado,
        error: errorEnvio
      }
    });
  } catch (error) {
    console.error("‚ùå Error procesando notificaci√≥n de chat humano:", error);
    res.status(500).json({ error: "Error procesando notificaci√≥n", details: error.message });
  }
});

app.listen(PORT, async () => {
  console.log(`‚úÖ Venom-service corriendo en puerto ${PORT}`);
  console.log(`üìÅ Carpeta de sesiones configurada: ${process.env.SESSION_FOLDER || path.join(__dirname, "tokens")}`);
  console.log(`üîç Verificando si existe /app/tokens:`, fs.existsSync("/app/tokens"));
  
  if (fs.existsSync("/app/tokens")) {
    const folders = fs.readdirSync("/app/tokens").filter(item => !isNaN(item));
    console.log(`üìÇ Carpetas num√©ricas encontradas en /app/tokens:`, folders);
  }
  
  // Esperar un poco para asegurar que la DB est√© lista
  console.log("‚è±Ô∏è Esperando conexi√≥n estable a la base de datos...");
  await new Promise(resolve => setTimeout(resolve, 3000));
  
  await restaurarSesiones();
});

app.post("/crear-sesiones-faltantes", async (req, res) => {
  try {
    // Obtener clientes de la DB
    const result = await pool.query("SELECT id, comercio FROM tenants");
    const clientesActivos = result.rows.map(row => String(row.id));
    
    // Obtener carpetas existentes
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    const carpetas = fs.existsSync(sessionDir) ? 
      fs.readdirSync(sessionDir).filter(item => {
        const itemPath = path.join(sessionDir, item);
        return fs.statSync(itemPath).isDirectory() && !isNaN(item);
      }) : [];
    
    const clientesSinCarpetas = clientesActivos.filter(id => !carpetas.includes(id));
    
    if (clientesSinCarpetas.length === 0) {
      return res.json({
        mensaje: "Todos los clientes ya tienen sesiones creadas",
        clientes_activos: clientesActivos,
        carpetas_existentes: carpetas
      });
    }
    
    console.log(`üöÄ API: Creando ${clientesSinCarpetas.length} sesiones faltantes...`);
    const resultados = [];
    
    for (const clienteId of clientesSinCarpetas) {
      try {
        console.log(`‚öôÔ∏è API: Creando sesi√≥n para cliente ${clienteId}...`);
        
        await Promise.race([
          crearSesion(clienteId, true),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error("Timeout de 25 segundos")), 25000)
          )
        ]);
        
        resultados.push({
          cliente_id: clienteId,
          estado: "creado",
          qr_url: `/qr/${clienteId}`
        });
        
        console.log(`‚úÖ API: Sesi√≥n creada para cliente ${clienteId}`);
        
        // Esperar entre creaciones
        await new Promise(resolve => setTimeout(resolve, 2000));
        
      } catch (err) {
        console.error(`‚ùå API: Error con cliente ${clienteId}:`, err.message);
        resultados.push({
          cliente_id: clienteId,
          estado: "error",
          error: err.message
        });
      }
    }
    
    res.json({
      mensaje: `Proceso completado. ${resultados.filter(r => r.estado === 'creado').length} sesiones creadas.`,
      resultados: resultados,
      clientes_procesados: clientesSinCarpetas.length
    });
    
  } catch (error) {
    console.error("‚ùå Error en crear-sesiones-faltantes:", error);
    res.status(500).json({ error: "Error creando sesiones", details: error.message });
  }
});

// Endpoint de salud para verificar estado de sesiones
app.get("/health", async (req, res) => {
  try {
    const estadoSesiones = {};
    
    for (const clienteId in sessions) {
      try {
        const isConnected = await verificarEstadoSesion(clienteId);
        const state = sessions[clienteId] ? await sessions[clienteId].getConnectionState() : 'NO_SESSION';
        
        estadoSesiones[clienteId] = {
          conectada: isConnected,
          estado: state,
          existe: !!sessions[clienteId]
        };
      } catch (e) {
        estadoSesiones[clienteId] = {
          conectada: false,
          estado: 'ERROR',
          existe: !!sessions[clienteId],
          error: e.message
        };
      }
    }
    
    const totalSesiones = Object.keys(sessions).length;
    const sesionesConectadas = Object.values(estadoSesiones).filter(s => s.conectada).length;
    
    res.json({
      status: "healthy",
      timestamp: new Date().toISOString(),
      sesiones: {
        total: totalSesiones,
        conectadas: sesionesConectadas,
        desconectadas: totalSesiones - sesionesConectadas,
        detalle: estadoSesiones
      }
    });
  } catch (error) {
    res.status(500).json({
      status: "unhealthy",
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Endpoint para reconectar una sesi√≥n espec√≠fica
app.post("/reconectar/:clienteId", async (req, res) => {
  const clienteId = req.params.clienteId;
  
  try {
    console.log(`üîÑ Solicitud manual de reconexi√≥n para sesi√≥n ${clienteId}`);
    
    // Verificar que el cliente existe en la DB
    const cliente = await pool.query("SELECT id, comercio FROM tenants WHERE id = $1", [clienteId]);
    if (cliente.rows.length === 0) {
      return res.status(404).json({ error: "Cliente no encontrado en la base de datos" });
    }
    
    await reconectarSesion(clienteId);
    
    res.json({
      success: true,
      message: `Reconexi√≥n iniciada para sesi√≥n ${clienteId}`,
      cliente: cliente.rows[0].comercio
    });
  } catch (error) {
    console.error(`‚ùå Error en reconexi√≥n manual ${clienteId}:`, error);
    res.status(500).json({
      error: "Error iniciando reconexi√≥n",
      details: error.message
    });
  }
});

// Endpoint para reconectar todas las sesiones desconectadas
app.post("/reconectar-todas", async (req, res) => {
  try {
    console.log(`üîÑ Solicitud manual de reconexi√≥n para todas las sesiones`);
    
    const sesionesDesconectadas = [];
    const errores = [];
    
    for (const clienteId in sessions) {
      const estaConectada = await verificarEstadoSesion(clienteId);
      
      if (!estaConectada) {
        sesionesDesconectadas.push(clienteId);
        
        try {
          await reconectarSesion(clienteId);
        } catch (error) {
          errores.push({ clienteId, error: error.message });
        }
      }
    }
    
    res.json({
      success: true,
      message: "Reconexi√≥n masiva iniciada",
      sesionesDesconectadas,
      errores,
      total: sesionesDesconectadas.length
    });
  } catch (error) {
    console.error("‚ùå Error en reconexi√≥n masiva:", error);
    res.status(500).json({
      error: "Error iniciando reconexi√≥n masiva",
      details: error.message
    });
  }
});

// Endpoint espec√≠fico para regenerar QR de un cliente
app.post("/regenerar-qr/:clienteId", async (req, res) => {
  const { clienteId } = req.params;
  
  try {
    console.log(`üîÑ ===== REGENERACI√ìN QR CLIENTE ${clienteId} =====`);
    console.log(`‚è∞ Timestamp: ${new Date().toISOString()}`);
    
    // 1. Verificar que el cliente existe en la base de datos
    let clienteInfo = null;
    try {
      const result = await pool.query("SELECT id, comercio, qr_code FROM tenants WHERE id = $1", [clienteId]);
      if (result.rows.length === 0) {
        console.log(`‚ùå Cliente ${clienteId} no existe en la base de datos`);
        return res.status(404).json({ 
          error: `Cliente ${clienteId} no existe en la base de datos`,
          action: "verificar_cliente"
        });
      }
      clienteInfo = result.rows[0];
      console.log(`‚úÖ Cliente encontrado: ${clienteInfo.comercio}`);
      console.log(`üìä QR actual en DB: ${clienteInfo.qr_code ? 'S√ç' : 'NO'} (length: ${clienteInfo.qr_code?.length || 0})`);
    } catch (dbError) {
      console.error(`‚ùå Error verificando cliente en BD: ${dbError.message}`);
      return res.status(500).json({ error: "Error verificando cliente en base de datos" });
    }
    
    // 2. Cerrar sesi√≥n existente completamente
    if (sessions[clienteId]) {
      console.log(`üîí Cerrando sesi√≥n existente en memoria...`);
      try {
        await sessions[clienteId].close();
        console.log(`‚úÖ Sesi√≥n cerrada correctamente`);
      } catch (closeError) {
        console.log(`‚ö†Ô∏è Error cerrando sesi√≥n: ${closeError.message}`);
      }
      delete sessions[clienteId];
      console.log(`üóëÔ∏è Sesi√≥n eliminada de memoria`);
    } else {
      console.log(`‚ÑπÔ∏è No hab√≠a sesi√≥n activa en memoria`);
    }
    
    // 3. Limpiar todos los archivos de sesi√≥n
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    const rutasLimpiar = [
      path.join(sessionDir, clienteId),
      `/app/tokens/${clienteId}`,
      path.join(sessionDir, `${clienteId}.html`)
    ];
    
    for (const rutaLimpiar of rutasLimpiar) {
      if (fs.existsSync(rutaLimpiar)) {
        console.log(`üóëÔ∏è Eliminando: ${rutaLimpiar}`);
        try {
          if (fs.statSync(rutaLimpiar).isDirectory()) {
            fs.rmSync(rutaLimpiar, { recursive: true, force: true });
          } else {
            fs.unlinkSync(rutaLimpiar);
          }
          console.log(`‚úÖ Eliminado: ${rutaLimpiar}`);
        } catch (deleteError) {
          console.log(`‚ö†Ô∏è Error eliminando ${rutaLimpiar}: ${deleteError.message}`);
        }
      } else {
        console.log(`‚ÑπÔ∏è No existe: ${rutaLimpiar}`);
      }
    }
    
    // 4. Limpiar QR en base de datos forzadamente
    try {
      const cleanResult = await pool.query("UPDATE tenants SET qr_code = NULL WHERE id = $1", [clienteId]);
      console.log(`üßπ QR limpiado en DB, filas afectadas: ${cleanResult.rowCount}`);
    } catch (dbError) {
      console.log(`‚ö†Ô∏è Error limpiando QR en BD: ${dbError.message}`);
    }
    
    // 5. Crear nueva sesi√≥n con logs detallados
    console.log(`üöÄ Creando nueva sesi√≥n con QR...`);
    
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error("Timeout de 45 segundos para generar QR")), 45000)
    );
    
    try {
      await Promise.race([
        crearSesionConTimeout(clienteId, 40000, true), // 40 segundos para crear sesi√≥n + QR
        timeoutPromise
      ]);
      
      // 6. Verificar que el QR se guard√≥ correctamente
      console.log(`üîç Verificando que el QR se guard√≥ en la base de datos...`);
      await new Promise(resolve => setTimeout(resolve, 2000)); // Esperar 2 segundos
      
      const verificacionResult = await pool.query("SELECT qr_code FROM tenants WHERE id = $1", [clienteId]);
      const qrEnDB = verificacionResult.rows[0]?.qr_code;
      
      const response = {
        success: true,
        mensaje: `QR regenerado exitosamente para cliente ${clienteId}`,
        cliente: clienteInfo.comercio,
        qr_url: `/qr/${clienteId}`,
        qr_guardado_en_db: !!qrEnDB,
        qr_length: qrEnDB?.length || 0,
        timestamp: new Date().toISOString()
      };
      
      if (qrEnDB) {
        console.log(`‚úÖ QR verificado en DB exitosamente (length: ${qrEnDB.length})`);
      } else {
        console.log(`‚ö†Ô∏è QR no encontrado en DB despu√©s de la regeneraci√≥n`);
        response.warning = "QR generado pero no verificado en base de datos";
      }
      
      console.log(`üéâ ===== REGENERACI√ìN COMPLETADA PARA CLIENTE ${clienteId} =====`);
      res.json(response);
      
    } catch (createError) {
      console.error(`‚ùå Error creando nueva sesi√≥n: ${createError.message}`);
      console.log(`üîç Stack trace:`, createError.stack);
      
      res.status(500).json({
        error: "Error regenerando QR",
        details: createError.message,
        action: "reintentar",
        qr_url: `/qr/${clienteId}`,
        cliente: clienteInfo.comercio
      });
    }
    
  } catch (error) {
    console.error(`‚ùå Error general en regenerar-qr para ${clienteId}:`, error);
    res.status(500).json({ 
      error: "Error interno del servidor",
      details: error.message 
    });
  }
});

// Endpoint para diagnosticar problemas espec√≠ficos de QR
app.get("/debug/qr/:clienteId", async (req, res) => {
  const { clienteId } = req.params;
  
  try {
    console.log(`üîç ===== DIAGN√ìSTICO QR CLIENTE ${clienteId} =====`);
    
    const diagnostico = {
      clienteId,
      timestamp: new Date().toISOString(),
      baseDatos: {},
      archivos: {},
      sesion: {},
      configuracion: {}
    };
    
    // 1. Verificar en base de datos
    try {
      const result = await pool.query("SELECT id, comercio, qr_code FROM tenants WHERE id = $1", [clienteId]);
      if (result.rows.length > 0) {
        const cliente = result.rows[0];
        diagnostico.baseDatos = {
          existe: true,
          comercio: cliente.comercio,
          tiene_qr: !!cliente.qr_code,
          qr_length: cliente.qr_code?.length || 0,
          qr_preview: cliente.qr_code ? cliente.qr_code.substring(0, 50) + '...' : null
        };
      } else {
        diagnostico.baseDatos = { existe: false };
      }
    } catch (err) {
      diagnostico.baseDatos = { error: err.message };
    }
    
    // 2. Verificar archivos de sesi√≥n
    const sessionDir = process.env.SESSION_FOLDER || path.join(__dirname, "tokens");
    const rutasVerificar = [
      { nombre: 'sessionDir', ruta: path.join(sessionDir, clienteId) },
      { nombre: 'appTokens', ruta: `/app/tokens/${clienteId}` },
      { nombre: 'qrHtml', ruta: path.join(sessionDir, `${clienteId}.html`) }
    ];
    
    diagnostico.archivos.rutas = {};
    for (const { nombre, ruta } of rutasVerificar) {
      const existe = fs.existsSync(ruta);
      diagnostico.archivos.rutas[nombre] = {
        ruta,
        existe,
        tipo: existe ? (fs.statSync(ruta).isDirectory() ? 'directorio' : 'archivo') : null
      };
      
      if (existe && fs.statSync(ruta).isDirectory()) {
        diagnostico.archivos.rutas[nombre].contenido = fs.readdirSync(ruta);
        
        // Verificar Default folder si es un directorio de sesi√≥n
        const defaultPath = path.join(ruta, 'Default');
        if (fs.existsSync(defaultPath)) {
          diagnostico.archivos.rutas[nombre].defaultFolder = {
            existe: true,
            archivos: fs.readdirSync(defaultPath).slice(0, 10) // Primeros 10 archivos
          };
        }
      }
      
      if (existe && !fs.statSync(ruta).isDirectory() && nombre === 'qrHtml') {
        // Para el archivo HTML del QR, verificar su contenido
        try {
          const content = fs.readFileSync(ruta, 'utf8');
          diagnostico.archivos.rutas[nombre].contentLength = content.length;
          diagnostico.archivos.rutas[nombre].isValidHTML = content.includes('<img src="data:image');
        } catch (e) {
          diagnostico.archivos.rutas[nombre].readError = e.message;
        }
      }
    }
    
    // 3. Verificar sesi√≥n en memoria
    diagnostico.sesion = {
      existe: !!sessions[clienteId],
      tipo: sessions[clienteId] ? typeof sessions[clienteId] : null
    };
    
    if (sessions[clienteId]) {
      try {
        const estado = await sessions[clienteId].getConnectionState();
        diagnostico.sesion.estado = estado;
        
        const isConnected = await sessions[clienteId].isConnected();
        diagnostico.sesion.conectado = isConnected;
        
        // Verificar m√©todos disponibles
        diagnostico.sesion.metodos = {
          getConnectionState: typeof sessions[clienteId].getConnectionState === 'function',
          isConnected: typeof sessions[clienteId].isConnected === 'function',
          sendText: typeof sessions[clienteId].sendText === 'function',
          close: typeof sessions[clienteId].close === 'function'
        };
        
      } catch (err) {
        diagnostico.sesion.error = err.message;
      }
    }
    
    // 4. Configuraci√≥n relevante
    diagnostico.configuracion = {
      SESSION_FOLDER: process.env.SESSION_FOLDER || 'default',
      sessionDirCalculado: sessionDir,
      nodeVersion: process.version,
      platform: process.platform
    };
    
    // 5. Recomendaciones
    diagnostico.recomendaciones = [];
    
    if (!diagnostico.baseDatos.existe) {
      diagnostico.recomendaciones.push("‚ùå Cliente no existe en base de datos");
    }
    
    if (diagnostico.baseDatos.existe && !diagnostico.baseDatos.tiene_qr) {
      diagnostico.recomendaciones.push("‚ö†Ô∏è Cliente existe pero no tiene QR en BD");
    }
    
    if (!diagnostico.archivos.rutas.qrHtml.existe) {
      diagnostico.recomendaciones.push("‚ö†Ô∏è No existe archivo HTML del QR");
    }
    
    if (!diagnostico.sesion.existe) {
      diagnostico.recomendaciones.push("‚ÑπÔ∏è No hay sesi√≥n activa en memoria - usar /regenerar-qr para crear");
    } else if (diagnostico.sesion.estado !== 'CONNECTED') {
      diagnostico.recomendaciones.push("‚ö†Ô∏è Sesi√≥n existe pero no est√° conectada");
    }
    
    const carpetasDisponibles = Object.values(diagnostico.archivos.rutas)
      .filter(r => r.existe && r.tipo === 'directorio').length;
    
    if (carpetasDisponibles === 0) {
      diagnostico.recomendaciones.push("üÜï No hay datos de sesi√≥n - requiere escaneo de QR desde cero");
    } else {
      diagnostico.recomendaciones.push(`‚ÑπÔ∏è ${carpetasDisponibles} carpeta(s) de sesi√≥n disponible(s) - posible restauraci√≥n`);
    }
    
    if (diagnostico.recomendaciones.length === 0) {
      diagnostico.recomendaciones.push("‚úÖ Todo parece estar en orden");
    }
    
    console.log(`üìã Diagn√≥stico QR completo para cliente ${clienteId}:`, JSON.stringify(diagnostico, null, 2));
    
    res.json(diagnostico);
    
  } catch (error) {
    console.error(`‚ùå Error en diagn√≥stico QR de cliente ${clienteId}:`, error);
    res.status(500).json({ error: error.message });
  }
});